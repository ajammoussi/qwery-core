import type { ActionFunctionArgs } from 'react-router';
import {
  type UIMessage,
  FactoryAgent,
  validateUIMessages,
} from '@qwery/agent-factory-sdk';
import { MessageRole } from '@qwery/domain/entities';
import { createRepositories } from '~/lib/repositories/repositories-factory';
import { handleDomainException } from '~/lib/utils/error-handler';
import { v4 as uuidv4 } from 'uuid';

const agents = new Map<string, FactoryAgent>();
const agentLastAccess = new Map<string, number>();
const agentCreationLocks = new Map<string, Promise<FactoryAgent>>();

const AGENT_INACTIVITY_TIMEOUT = 30 * 60 * 1000;
const CLEANUP_INTERVAL = 5 * 60 * 1000;

if (typeof setInterval !== 'undefined') {
  setInterval(() => {
    const now = Date.now();
    for (const [slug, lastAccess] of agentLastAccess.entries()) {
      if (now - lastAccess > AGENT_INACTIVITY_TIMEOUT) {
        const agent = agents.get(slug);
        if (agent) {
          try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (agent as any).factoryActor?.stop();
          } catch (error) {
            console.warn(`Error stopping agent ${slug}:`, error);
          }
          agents.delete(slug);
          agentLastAccess.delete(slug);
          agentCreationLocks.delete(slug);
          console.log(`Cleaned up inactive agent for conversation ${slug}`);
        }
      }
    }
  }, CLEANUP_INTERVAL);
}

const repositories = await createRepositories();

async function getOrCreateConversation(
  notebookId: string,
  datasourceId: string,
  projectId: string,
  userId: string,
): Promise<string> {
  // Each notebook has its own conversation that all cells share
  // First, try to find an existing conversation for this notebook
  const existingConversations =
    await repositories.conversation.findByProjectId(projectId);
  
  // Look for a conversation with title matching this notebook
  // We use a pattern: "Notebook - {notebookId}" to identify notebook conversations
  const notebookTitle = `Notebook - ${notebookId}`;
  const matchingConversation = existingConversations.find(
    (conv) => conv.title === notebookTitle,
  );

  if (matchingConversation) {
    // Update datasources if needed (add this datasource if not present)
    if (
      matchingConversation.datasources &&
      !matchingConversation.datasources.includes(datasourceId)
    ) {
      await repositories.conversation.update({
        ...matchingConversation,
        datasources: [...matchingConversation.datasources, datasourceId],
        updatedBy: userId,
        updatedAt: new Date(),
      });
    }
    return matchingConversation.slug;
  }

  // Create new conversation for this notebook
  // Note: The repository will generate its own slug from the ID, so we don't set slug here
  const conversationId = uuidv4();
  const now = new Date();
  let conversation;
  
  try {
    conversation = await repositories.conversation.create({
      id: conversationId,
      slug: '', // Repository will generate slug from ID
      title: notebookTitle,
      projectId,
      taskId: uuidv4(), // TODO: Create or get actual task
      datasources: [datasourceId],
      createdAt: now,
      updatedAt: now,
      createdBy: userId,
      updatedBy: userId,
      seedMessage: '',
    });
  } catch (error) {
    // If creation fails (e.g., due to race condition), try to find it again
    const retryConversations =
      await repositories.conversation.findByProjectId(projectId);
    const retryMatch = retryConversations.find(
      (conv) => conv.title === notebookTitle,
    );
    if (retryMatch) {
      return retryMatch.slug;
    }
    throw error;
  }

  // Return the slug that was generated by the repository
  return conversation.slug;
}

async function getOrCreateAgent(
  conversationSlug: string,
  model: string = 'azure/gpt-5-mini',
): Promise<FactoryAgent> {
  let agent = agents.get(conversationSlug);
  if (agent) {
    agentLastAccess.set(conversationSlug, Date.now());
    return agent;
  }

  const existingLock = agentCreationLocks.get(conversationSlug);
  if (existingLock) {
    return existingLock;
  }

  const creationPromise = (async () => {
    try {
      const conversation =
        await repositories.conversation.findBySlug(conversationSlug);
      if (!conversation) {
        throw new Error(
          `Conversation with slug '${conversationSlug}' not found`,
        );
      }

      agent = await FactoryAgent.create({
        conversationSlug: conversationSlug,
        model: model,
        repositories: repositories,
      });

      agents.set(conversationSlug, agent);
      agentLastAccess.set(conversationSlug, Date.now());
      agentCreationLocks.delete(conversationSlug);
      console.log(
        `Agent ${agent.id} created for conversation ${conversationSlug}`,
      );
      return agent;
    } catch (error) {
      agentCreationLocks.delete(conversationSlug);
      throw error;
    }
  })();

  agentCreationLocks.set(conversationSlug, creationPromise);
  return creationPromise;
}

async function extractSqlFromAgentResponse(
  response: Response,
): Promise<string | null> {
  if (!response.body) {
    return null;
  }

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = '';
  let sqlQuery: string | null = null;
  let fullText = '';

  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }

      const chunk = decoder.decode(value, { stream: true });
      buffer += chunk;
      fullText += chunk;

      // Parse SSE format
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';

      for (const line of lines) {
        if (!line.trim() || line.startsWith(':')) {
          continue;
        }

        if (line.startsWith('data: ')) {
          const data = line.slice(6).trim();

          if (data === '[DONE]') {
            continue;
          }

          try {
            const parsed = JSON.parse(data);

            // Look for tool calls with SQL queries
            // Format: { type: 'tool-call', toolName: 'runQuery', args: { query: '...' } }
            if (parsed.type === 'tool-call' && parsed.toolName === 'runQuery') {
              if (parsed.args?.query) {
                sqlQuery = parsed.args.query;
              }
            }

            // Check for tool parts in message updates
            // Format: { type: 'message-part', part: { type: 'tool-runQuery', input: { query: '...' } } }
            if (parsed.type === 'message-part' && parsed.part) {
              const part = parsed.part;
              if (
                (part.type === 'tool-runQuery' || part.type === 'tool-call') &&
                part.input?.query
              ) {
                sqlQuery = part.input.query;
              }
            }

            // Also check for tool input in different formats
            if (parsed.type === 'tool-call' && parsed.toolName === 'runQuery') {
              if (parsed.input?.query) {
                sqlQuery = parsed.input.query;
              }
            }

            // Check for tool parts directly
            if (parsed.type === 'tool-runQuery' && parsed.input?.query) {
              sqlQuery = parsed.input.query;
            }

            // Check for tool results that might contain SQL
            if (
              parsed.type === 'tool-result' &&
              parsed.toolName === 'runQuery' &&
              parsed.result?.sqlQuery
            ) {
              sqlQuery = parsed.result.sqlQuery;
            }

            // Check message parts for tool calls
            if (parsed.type === 'text-delta' || parsed.type === 'text') {
              // Look for SQL in text responses as fallback
              const text = parsed.delta || parsed.text || '';
              const sqlMatch = text.match(
                /(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\s+[\s\S]*?(?=\n\n|\n$|$)/i,
              );
              if (sqlMatch && !sqlQuery) {
                sqlQuery = sqlMatch[0].trim();
              }
            }
          } catch {
            // Ignore parse errors
          }
        }
      }
    }

    // Fallback: Try to extract SQL from the full text if we didn't find it in tool calls
    if (!sqlQuery && fullText) {
      const sqlMatch = fullText.match(
        /(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER|DROP)\s+[\s\S]*?(?=\n\n|\n$|$)/i,
      );
      if (sqlMatch) {
        sqlQuery = sqlMatch[0].trim();
      }
    }
  } finally {
    reader.releaseLock();
  }

  return sqlQuery;
}

export async function action({ request }: ActionFunctionArgs) {
  if (request.method !== 'POST') {
    return new Response('Method not allowed', { status: 405 });
  }

  const body = await request.json();
  const {
    query,
    notebookId,
    datasourceId,
    projectId,
    userId,
    model = 'azure/gpt-5-mini',
  } = body;

  if (!query || !notebookId || !datasourceId || !projectId || !userId) {
    return new Response('Missing required fields', { status: 400 });
  }

  try {
    // Create or get conversation for this notebook + datasource
    const conversationSlug = await getOrCreateConversation(
      notebookId,
      datasourceId,
      projectId,
      userId,
    );

    // Verify conversation exists before creating agent
    const conversation = await repositories.conversation.findBySlug(
      conversationSlug,
    );
    if (!conversation) {
      throw new Error(
        `Failed to create or find conversation with slug '${conversationSlug}'`,
      );
    }

    // Get or create agent
    const agent = await getOrCreateAgent(conversationSlug, model);

    // Create user message
    const messages: UIMessage[] = [
      {
        id: uuidv4(),
        role: 'user',
        parts: [{ type: 'text', text: query }],
      },
    ];

    // Get agent response
    const streamResponse = await agent.respond({
      messages: await validateUIMessages({ messages }),
    });

    // Extract SQL from the response and detect if SQL was generated
    const sqlQuery = await extractSqlFromAgentResponse(streamResponse);
    const hasSql = !!sqlQuery;

    // Return response with both SQL (if available) and conversation info
    return new Response(
      JSON.stringify({
        sqlQuery: sqlQuery || null,
        hasSql,
        conversationSlug,
        // If no SQL, the client should open the chat interface with this conversation
      }),
      {
        headers: { 'Content-Type': 'application/json' },
      },
    );
  } catch (error) {
    return handleDomainException(error);
  }
}

